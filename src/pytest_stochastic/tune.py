"""Tune mode for stochastic tests.

When ``--stochastic-tune`` is passed to pytest, each stochastic test function
is run ``n_tune`` times (default 50,000).  The framework computes a rigorous
upper confidence bound on the variance and persists the result to
``.stochastic.toml`` so that subsequent test runs can use tighter bounds.
"""

from __future__ import annotations

import math
import tomllib
from dataclasses import dataclass
from datetime import UTC, datetime
from pathlib import Path

import numpy as np
from scipy import stats as sp_stats

from .runtime import _wants_rng, make_rng


@dataclass
class TuneResult:
    """Result of tuning a single stochastic test."""

    test_key: str
    variance: float
    observed_range: tuple[float, float]
    n_tune_samples: int
    tuned_at: str


def compute_variance_ucb(
    samples: np.ndarray,
    confidence: float = 1e-4,
) -> float:
    """Compute a one-sided upper confidence bound on the true variance.

    Uses the chi-squared distribution:
        var_upper = (n - 1) * var_hat / chi2_quantile(delta, n - 1)

    where chi2_quantile(delta, n-1) is the delta-quantile of the chi-squared
    distribution.  This ensures P(var_true <= var_upper) >= 1 - confidence.
    """
    n = len(samples)
    if n < 2:
        return float("inf")

    sample_var = float(np.var(samples, ddof=1))
    # Lower quantile of chi-squared: smaller quantile → larger UCB
    chi2_quantile = sp_stats.chi2.ppf(confidence, df=n - 1)
    if chi2_quantile <= 0:
        return float("inf")

    return (n - 1) * sample_var / chi2_quantile


def run_tune(
    func: object,
    n_tune: int,
    seed: int | None = None,
) -> tuple[np.ndarray, int]:
    """Run a test function n_tune times and collect samples.

    Returns (samples_array, seed_used).
    """
    rng, actual_seed = make_rng(seed)
    inject_rng = _wants_rng(func)

    samples = np.empty(n_tune, dtype=np.float64)
    for i in range(n_tune):
        result = func(rng=rng) if inject_rng else func()  # type: ignore[operator]
        samples[i] = float(result)

    return samples, actual_seed


def tune_test(
    func: object,
    test_key: str,
    n_tune: int = 50_000,
    confidence: float = 1e-4,
    seed: int | None = None,
) -> TuneResult:
    """Run the tuning procedure for a single test function.

    Collects n_tune samples, computes variance UCB, and returns a TuneResult.
    """
    samples, _ = run_tune(func, n_tune, seed=seed)

    variance_ucb = compute_variance_ucb(samples, confidence=confidence)
    observed_min = float(np.min(samples))
    observed_max = float(np.max(samples))

    return TuneResult(
        test_key=test_key,
        variance=variance_ucb,
        observed_range=(observed_min, observed_max),
        n_tune_samples=n_tune,
        tuned_at=datetime.now(UTC).isoformat(),
    )


# ---------------------------------------------------------------------------
# .stochastic.toml persistence
# ---------------------------------------------------------------------------

_TOML_FILENAME = ".stochastic.toml"


def _toml_path(root: Path | None = None) -> Path:
    """Return the path to .stochastic.toml."""
    if root is None:
        root = Path.cwd()
    return root / _TOML_FILENAME


def load_tuned_params(root: Path | None = None) -> dict[str, dict[str, object]]:
    """Load tuned parameters from .stochastic.toml.

    Returns a dict mapping test keys to their tuned parameter dicts.
    Each entry has: variance, observed_range, tuned_at, n_tune_samples.
    """
    path = _toml_path(root)
    if not path.exists():
        return {}

    with open(path, "rb") as f:
        data = tomllib.load(f)

    tests = data.get("tests", {})
    result: dict[str, dict[str, object]] = {}
    for key, params in tests.items():
        result[key] = dict(params)
    return result


def save_tuned_params(
    results: list[TuneResult],
    root: Path | None = None,
) -> Path:
    """Write tuned parameters to .stochastic.toml.

    Merges with existing data — existing entries for different tests are
    preserved, and entries for tests in *results* are updated.
    """
    path = _toml_path(root)

    # Load existing data
    existing = load_tuned_params(root)

    # Merge results
    for r in results:
        existing[r.test_key] = {
            "variance": r.variance,
            "observed_range": list(r.observed_range),
            "tuned_at": r.tuned_at,
            "n_tune_samples": r.n_tune_samples,
        }

    # Write TOML manually (stdlib tomllib is read-only)
    lines = ["# Auto-generated by pytest-stochastic --stochastic-tune", ""]

    for test_key, params in sorted(existing.items()):
        # TOML section: [tests."module::test_name"]
        lines.append(f'[tests."{test_key}"]')
        for k, v in sorted(params.items()):
            lines.append(f"{k} = {_toml_value(v)}")
        lines.append("")

    path.write_text("\n".join(lines) + "\n")
    return path


def _toml_value(v: object) -> str:
    """Format a Python value as a TOML literal."""
    if isinstance(v, bool):
        return "true" if v else "false"
    if isinstance(v, int):
        return str(v)
    if isinstance(v, float):
        if math.isinf(v):
            return "inf" if v > 0 else "-inf"
        if math.isnan(v):
            return "nan"
        return repr(v)
    if isinstance(v, str):
        return f'"{v}"'
    if isinstance(v, (list, tuple)):
        items = ", ".join(_toml_value(x) for x in v)
        return f"[{items}]"
    return repr(v)
